#include "RMSD.h"

using namespace jian;

RMSD::RMSD() {
	isRNA1 = 0;
	isRNA2 = 0;
	isSeq1 = 0;
	isSeq2 = 0;
}

RMSD::RMSD(string filename) {
	isRNA1 = 0;
	isRNA2 = 0;
	isSeq1 = 0;
	isSeq2 = 0;
	ifstream ifile(filename.c_str());
	while (ifile) {
		string line;
		getline(ifile, line);
		vector<string> splitedLine;
		tokenize(line, splitedLine, ":, ");
		if (splitedLine.size() >= 2) {
			if (splitedLine[0] == "RNA1" || splitedLine[0] == "rna1") {
				refRNA = new RNA(splitedLine[1]);
				isRNA1 = 1;
			} else if (splitedLine[0] == "RNA2" || splitedLine[0] == "rna2") {
				objRNA = new RNA(splitedLine[1]);
				isRNA2 = 1;
			} else if (splitedLine[0] == "seq1") {
				for (int i = 1; i < splitedLine.size(); i++) {
					vector<string> splitedStr;
					tokenize(splitedLine[i], splitedStr, "-");
					if (splitedStr.size() == 1) {
						int n = atoi(splitedStr[0].c_str());
						seqFlags1.push_back(n - 1);
					} else if (splitedStr.size() > 1) {
						int n1 = atoi(splitedStr[0].c_str());
						int n2 = atoi(splitedStr[1].c_str());
						for (int j = n1 - 1; j < n2; j++) {
							seqFlags1.push_back(j);
						}
					}
				}
				isSeq1 = 1;
			} else if (splitedLine[0] == "seq2") {
				for (int i = 1; i < splitedLine.size(); i++) {
					vector<string> splitedStr;
					tokenize(splitedLine[i], splitedStr, "-");
					if (splitedStr.size() == 1) {
						int n = atoi(splitedStr[0].c_str());
						seqFlags2.push_back(n - 1);
					} else if (splitedStr.size() > 1) {
						int n1 = atoi(splitedStr[0].c_str());
						int n2 = atoi(splitedStr[1].c_str());
						for (int j = n1 - 1; j < n2; j++) {
							seqFlags2.push_back(j);
						}
					}
				}
				isSeq2 = 1;
			}
		}
	}
	ifile.close();
}

RMSD::RMSD(Obj<RNA> rna) {
	isRNA1 = 0;
	isRNA2 = 0;
	isSeq1 = 0;
	isSeq2 = 0;
	readRef(rna);
}

RMSD::RMSD(char *file1, char *file2) {
	len = 0;
	ifstream ifile(file1);
	double a, b, c;
	while (ifile) {
		ifile >> a >> b >> c;
		len++;
	}
	ifile.close();
	x.resize(3, len);
	y.resize(3, len);
	ifile.open(file1);
	int flag = 0;
	while (ifile) {
		ifile >> x(0, flag) >> x(1, flag) >> x(2, flag);
		flag++;
	}
	ifile.close();
	ifile.open(file2);
	flag = 0;
	while (ifile) {
		ifile >> y(0, flag) >> y(1, flag) >> y(2, flag);
		flag++;
	}
	ifile.close();
}

RMSD::RMSD(Obj<RNA> rna1, Obj<RNA> rna2) {
	isRNA1 = 0;
	isRNA2 = 0;
	isSeq1 = 0;
	isSeq2 = 0;
	readRef(rna1);
	readObj(rna2);
}

void RMSD::readRef(Obj<RNA> rna) {
	refRNA = rna;
	isRNA1 = 1;
}

void RMSD::readObj(Obj<RNA> rna) {
	objRNA = rna;
	isRNA2 = 1;
}

void RMSD::readSeq1(string str) {
	isSeq1 = 1;
	seqFlags1.clear();
	vector<string> splitedLine;
	tokenize(str, splitedLine, ",: ");
	for (int i = 0; i < splitedLine.size(); i++) {
		vector<string> splitedStr;
		tokenize(splitedLine[i], splitedStr, "-");
		if (splitedStr.size() == 1) {
			int n = atoi(splitedStr[0].c_str());
			seqFlags1.push_back(n - 1);
		} else if (splitedStr.size() > 1) {
			int n1 = atoi(splitedStr[0].c_str());
			int n2 = atoi(splitedStr[1].c_str());
			for (int j = n1 - 1; j < n2; j++) {
				seqFlags1.push_back(j);
			}
		}
	}
}

void RMSD::readSeq2(string str) {
	isSeq2 = 1;
	seqFlags2.clear();
	vector<string> splitedLine;
	tokenize(str, splitedLine, ",: ");
	for (int i = 0; i < splitedLine.size(); i++) {
		vector<string> splitedStr;
		tokenize(splitedLine[i], splitedStr, "-");
		if (splitedStr.size() == 1) {
			int n = atoi(splitedStr[0].c_str());
			seqFlags2.push_back(n - 1);
		} else if (splitedStr.size() > 1) {
			int n1 = atoi(splitedStr[0].c_str());
			int n2 = atoi(splitedStr[1].c_str());
			for (int j = n1 - 1; j < n2; j++) {
				seqFlags2.push_back(j);
			}
		}
	}
}

void RMSD::setXY() {
	if (isRNA1 != 1 || isRNA2 != 1) {
		cerr << "Please read two RNAs!" << endl;
		exit(1);
	}

	int len1 = refRNA->getLen();
	int len2 = objRNA->getLen();
	int flags1[len1], flags2[len2];
	for (int i = 0; i < len1; i++) {
		if (isSeq1 == 1) {
			flags1[i] = 0;
		} else {
			flags1[i] = 1;
		}
	}
	for (int i = 0; i < len2; i++) {
		if (isSeq2 == 1) {
			flags2[i] = 0;
		} else {
			flags2[i] = 1;
		}
	}
	if (isSeq1 == 1) {
		for (int i = 0; i < seqFlags1.size(); i++) {
			flags1[seqFlags1[i]] = 1;
		}
	}
	if (isSeq2 == 1) {
		for (int i = 0; i < seqFlags2.size(); i++) {
			flags2[seqFlags2[i]] = 1;
		}
	}
	int num1 = 0, num2 = 0;
	for (int i = 0; i < len1; i++) {
		if (flags1[i] == 1) {
			num1++;
		}
	}
	for (int i = 0; i < len2; i++) {
		if (flags2[i] == 1) {
			num2++;
		}
	}
	if (num1 != num2) {
		cerr << "The length of these two RNAs must be equal!" << endl;
		exit(1);
	}
	numRes = num1;

	int a[numRes];
	int b[numRes];
	string aa[numRes];
	string bb[numRes];
	for (int i = 0, index = 0, temp = 0; i < (int) refRNA->chains.size(); i++) {
		for (int j = 0; j < (int) refRNA->chains[i].residues.size(); j++, index++) {
			if (flags1[index] == 1) {
				aa[temp] = refRNA->chains[i].residues[j].name;
				if (refRNA->chains[i].residues[j].atoms[0].name == "P") {
					a[temp] = 0;
				} else {
					a[temp] = 1;
				}
				temp++;
			}
		}
	}
	for (int i = 0, index = 0, temp = 0; i < (int) objRNA->chains.size(); i++) {
		for (int j = 0; j < (int) objRNA->chains[i].residues.size(); j++, index++) {
			if (flags2[index] == 1) {
				bb[temp] = objRNA->chains[i].residues[j].name;
				if (objRNA->chains[i].residues[j].atoms[0].name == "P") {
					b[temp] = 0;
				} else {
					b[temp] = 1;
				}
				temp++;
			}
		}
	}

	int c[numRes];
	len = 0;
	for (int i = 0; i < numRes; i++) {
		if (aa[i] != bb[i]) {
			cerr << "The objective rna's sequence must be same with the reference rna's!" << endl;
			exit(1);
		}
		c[i] = (a[i] > b[i]) ? a[i] : b[i];
		if (aa[i] == "A") {
			len += 22;
		} else if (aa[i] == "U") {
			len += 20;
		} else if (aa[i] == "G") {
			len += 23;
		} else {
			len += 20;
		}
		if (c[i] == 1) {
			len -= 3;
		}
	}
	x.resize(3, len);
	y.resize(3, len);

	double c1[3];
	c1[0] = 0; c1[1] = 0; c1[2] = 0;
	for (int i = 0, ir = 0, ia = 0, temp = 0; i < (int) refRNA->chains.size(); i++) {
		for (int j = 0; j < (int) refRNA->chains[i].residues.size(); j++, ir++) {
			if (flags1[ir] == 0) continue;
			int k = 0;
			if (c[temp] == 1 && refRNA->chains[i].residues[j].atoms[0].name == "P") {
				k = 3;
			}
			for (; k < (int) refRNA->chains[i].residues[j].atoms.size(); k++, ia++) {
				x(0, ia) = refRNA->chains[i].residues[j].atoms[k].x;
				c1[0] += x(0, ia);
				x(1, ia) = refRNA->chains[i].residues[j].atoms[k].y;
				c1[1] += x(1, ia);
				x(2, ia) = refRNA->chains[i].residues[j].atoms[k].z;
				c1[2] += x(2, ia);
			}
			temp++;
		}
	}
	c1[0] = c1[0] / len;
	c1[1] = c1[1] / len;
	c1[2] = c1[2] / len;

	double c2[3];
	c2[0] = 0; c2[1] = 0; c2[2] = 0;
	for (int i = 0, ir = 0, ia = 0, temp = 0; i < (int) objRNA->chains.size(); i++) {
		for (int j = 0; j < (int) objRNA->chains[i].residues.size(); j++, ir++) {
			if (flags2[ir] == 0) continue;
			int k = 0;
			if (c[temp] == 1 && objRNA->chains[i].residues[j].atoms[0].name == "P") {
				k = 3;
			}
			for (; k < (int) objRNA->chains[i].residues[j].atoms.size(); k++, ia++) {
				y(0, ia) = objRNA->chains[i].residues[j].atoms[k].x;
				c2[0] += y(0, ia);
				y(1, ia) = objRNA->chains[i].residues[j].atoms[k].y;
				c2[1] += y(1, ia);
				y(2, ia) = objRNA->chains[i].residues[j].atoms[k].z;
				c2[2] += y(2, ia);
			}
			temp++;
		}
	}
	c2[0] = c2[0] / len;
	c2[1] = c2[1] / len;
	c2[2] = c2[2] / len;

	for (int i = 0; i < len; i++) {
		for (int j = 0; j < 3; j++) {
			x(j, i) = x(j, i) - c1[j];
			y(j, i) = y(j, i) - c2[j];
		}
	}
}

double RMSD::run() {
	setXY();
	Matrix3f g = x * y.transpose();

	JacobiSVD<Matrix3f> svd(g, ComputeFullU|ComputeFullV);
	Matrix3f u = svd.matrixU();
	Matrix3f v = svd.matrixV();

	double det = g.determinant();
	Matrix3f I;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (i == j) {
				I(i, j) = 1;
			} else {
				I(i, j) = 0;
			}
		}
	}
	if (det < 0) {
		I(2, 2) = -1;
	}
	Matrix3f r = v * I * u.transpose();

	MatrixXf x_ = r * x;

	rmsd = 0;
	for (int i = 0; i < len; i++) {
		for (int j = 0; j < 3; j++) {
			rmsd += (x_(j, i) - y(j, i)) * (x_(j, i) - y(j, i));
		}
	}
	rmsd /= len;
	rmsd = sqrt(rmsd);
	return rmsd;
}








