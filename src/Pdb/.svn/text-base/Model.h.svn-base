#ifndef Model_H
#define Model_H

#include "Chain.h"

namespace jian {

class Model
{
public:
	Model() {}
	Model(Model *model) : name(model->name), chains(model->chains) {}
	Model(const Model &model) : name(model.name), chains(model.chains) {}
	Model &operator =(const Model &model) {
		name = model.name;
		chains = model.chains;
	}
	Model(vector<string>);
	Model(std::string pdbfile) {
		/* set name */
		assert(pdbfile.substr(pdbfile.size() - 4, 4) == ".pdb");
		name = pdbfile.substr(0, pdbfile.size() - 4);

		/* set chains */
		ifstream ifile(pdbfile.c_str());
		assert(ifile);

		string line;
		vector<string> lines;
		int n = 0;
		while (getline(ifile, line, '\n')) {
			if (!line.compare(0, 4, "ATOM")) {
				n++;
				if (lines.size() != 0 && line[21] != lines.back()[21]) {
					chains.push_back(Chain(lines, name));
					lines.clear();
				}
				lines.push_back(line);
			}
		}

		n != 0 || die("The file '" + pdbfile + "' has nothing!");

		chains.push_back(Chain(lines, name));
		ifile.close();
	}

	int res_nums() const {
		int res_num = 0;
		for (auto &chain: chains) {
			for (auto &residue: chain.residues) {
				res_num++;
			}
		}
		return res_num;
	}

	int atom_nums() const {
		int atom_num = 0;
		for (auto &chain: chains) {
			for (auto &residue: chain.residues) {
				for (auto &atom: residue.atoms) {
					atom_num++;
				}
			}
		}
		return atom_num;
	}


//	void push(Obj<Chain>);
	void push(const Chain &);
	Chain &operator [](int);

	/* IO function */
	void print();
	void write(string);
	friend ostream &operator <<(ostream &, const Model &);
	
	/* attributes */
	string name = "none";
	vector<Chain> chains;

//	/* iteration */
//	int shift();
//	void init();
//	vector<Chain>::iterator begin();
//	vector<Chain>::iterator end();
//	
//	vector<Chain>::iterator _chain;
//	vector<Residue>::iterator _residue;
//	vector<Atom>::iterator _atom;
};

} /// namespace jian

#endif // Model_H

