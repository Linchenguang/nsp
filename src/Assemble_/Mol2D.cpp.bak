#include "Mol2D.h"

string Mol2D::del_single_pair(string ss) {
	string line = ss;

	// construct the base-pairing map
	vector<int> v;
	map<int, int> m;
	for (int i = 0; i < line.size(); i++) {
		if (line[i] == '(') {
			v.push_back(i);
		} else if (line[i] == ')') {
			m[v.back()] = i;
			m[i] = v.back();
			v.pop_back();
		}
	}

	// replace all the single base pair with '.'
	int len = line.size();
	int err_num = 1;
	while (err_num != 0) {
		err_num = 0;
		if (line[0] == '(' && line[1] != '(') {
			line[0] = '.';
			line[m[0]] = '.';
			err_num++;
		}
		if (line[len - 2] != ')' && line[len - 1] == ')') {
			line[len - 1] = '.';
			line[m[len - 1]] = '.';
			err_num++;
		}
		for (int i = 1; i + 1 < line.size(); i++) {
			if (line[i - 1] != '(' && line[i] == '(' && line[i + 1] != '(') {
				line[i] = '.';
				line[m[i]] = '.';
				err_num++;
			} else if (line[i - 1] != ')' && line[i] == ')' && line[i + 1] != ')') {
				line[i] = '.';
				line[m[i]] = '.';
				err_num++;
			}
		}
	}
	return line;
}

void Mol2D::setTree(vector<res> &v0, int view) {
	int i, j, temp, *a;
	res *r, *preRes, *tempRes;
	loop *l;
	vector<res> v, v1;
	vector<loop *> s;

	this->view = view;

	// start iteration
	if (view) {
		cout << "=================== iteration ====================\n";
	}

	// array a maps the line to ss
	a = new int[line.size() + 2];
	a[0] = -1;
	for (i = 1, temp = 0; i < (int) line.size() + 1; i++) {
		if (line[i - 1] == '&') {
			temp++;
			a[i] = -1;
		} else {
			a[i] = i - temp;
		}
	}
	a[i] = -1;

	// construct the vector
	for (i = 0, j = 1; j < (int) v0.size(); j++) {
		v1.push_back(v0[i]);
		if (v0[i].type == ')' && v0[j].type == '(') {
				tempRes = new res('|', v0[j].num);
				v1.push_back(*tempRes);
				delete tempRes;
				tempRes = new res('|', v0[i].num);
				v1.push_back(*tempRes);
				delete tempRes;
		}
		i = j;
	}
	v1.push_back(v0[i]);

	// main loop for tree setting
	for (i = 0; i < (int) v1.size(); i++) {
		if (v.size() != 0 && v.back().type == ')' && v1[i].type != ')') {
			getLoop(v, s, a);
		}
		v.push_back(v1[i]);
	}

	// add head
	l = new loop;
	l->isPartial = 1;
	r = new res(v[0].type, v[0].num);
	preRes = r;
	l->head = r;
	for (i = 1; i < (int) v.size(); i++) {
		r = new res(v[i].type, v[i].num);
		preRes->next = r;
		preRes = r;
	}

	// add interface
	int hinge_pos = -1;
	for (preRes = l->head, tempRes = preRes->next; tempRes != NULL; tempRes = tempRes->next) {
		if (tempRes->num - preRes->num > 1) {
			r = new res('(', preRes->num + 1);
			preRes->next = r;
			hinge_pos++;
			r->next = new res('(', preRes->num + 2);
			r = r->next;
			hinge_pos++;
			l->hinges.push_back(pair<int, int>(hinge_pos, hinge_pos + 1));
			r->next = new res(')', tempRes->num - 2);
			r = r->next;
			hinge_pos++;
			r->next = new res(')', tempRes->num - 1);
			r = r->next;
			r->next = tempRes;
			hinge_pos++;
			l->type++;
		}
		preRes = tempRes;
		if (tempRes->type != '|') {
			hinge_pos++;
		}
	}

	// delete '|'
	for (preRes = l->head, tempRes = preRes->next; tempRes != NULL; tempRes = tempRes->next) {
		if (tempRes->type == '|') {
			preRes->next = tempRes->next->next;
			delete tempRes->next;
			delete tempRes;
			tempRes = preRes->next;
			l->type--;
		}
		preRes = tempRes;
	}

	// set tree relation
//	if (s.size() != 0) {
//		temp = s.size() - l->type;
//		l->son = s[temp];
//		for (i = temp; i < (int) s.size() - 1; i++) {
//			s[i]->brother = s[i + 1];
//		}
//	}
	if (s.size() != 0) {
		l->son = s[0];
		for (int i = 0; i < s.size() - 1; i++) {
			s[i]->brother = s[i + 1];
		}
	}

	head = l;

	// delete '^'
	tempRes = l->head;
	l->head = l->head->next;
	delete tempRes; 

	// change head if the head does not exist
	if (l->getLen() == 4) {
		head = l->son;
		delete l;
	}

	// print "iteration done"
	if (view) {
		cout << endl;
		cout << "           *******************\n";
		cout << "           * iteration done! *\n";
		cout << "           *******************\n";
	}

	// construct pseudoknots
	constructPseudoknots();

	// reset the num
	resetNum(head, a);
	resetNum(pseudo_head, a);
	delete [] a;
}

void Mol2D::resetNum(loop *l, int *a) {
	if (l == NULL) {
		return;
	}
	if (l->head != NULL) {
		for (res *tempRes = l->head; tempRes != NULL; tempRes = tempRes->next) {
			if (tempRes->num >= 1 && tempRes->num <= line.size()) {
				tempRes->num = a[tempRes->num];
			}
		}
	}
	if (l->s.head != NULL) {
		for (bp *b = l->s.head; b != NULL; b = b->next) {
			if (b->res1.num >= 1 && b->res1.num <= line.size()) {
				b->res1.num = a[b->res1.num];
			}
			if (b->res2.num >= 1 && b->res2.num <= line.size()) {
				b->res2.num = a[b->res2.num];
			}
		}
	}
	resetNum(l->son, a);
	resetNum(l->brother, a);
}

void Mol2D::readSeq(string seq) {
	if (ss.size() != (int) seq.size()) {
		cerr << "The sequence's length is " << seq.size() << ", but the 2D structure's length is " << ss.size() << "!" << endl;
		cerr << "The size of 2D structure and sequence must be equal!" << endl;
		exit(1);
	}

	// set seq
	this->seq = seq;
	setSeq(head, seq);
	setSeq(pseudo_head, seq);
}

void Mol2D::setSeq(loop *l, string str) {
	res *tempRes;
	bp *b;

	if (l == NULL) {
		return;
	}
	if (l->head != NULL) {
		for (tempRes = l->head; tempRes != NULL; tempRes = tempRes->next) {
			if (tempRes->num - 1 >= 0 && tempRes->num - 1 < (int) str.size()) {
				tempRes->name = str[tempRes->num - 1];
			} else {
				tempRes->name = 'X';
			}
		}
	}
	if (l->s.head != NULL) {
		for (b = l->s.head; b != NULL; b = b->next) {
			b->res1.name = str[b->res1.num - 1];
			b->res2.name = str[b->res2.num - 1];
		}
	}
	setSeq(l->son, str);
	setSeq(l->brother, str);
}

void Mol2D::readMol(string name) {
	mol = new RNA(name);
}

void Mol2D::print() {
	cout << endl;
	cout << line << endl;
	cout << seq << endl;
	cout << "\n=============== 2D structure tree ===================\n\n";
	printTree(head);
	cout << "\n=============== 2D structure tree with pseudo-knots ===================\n\n";
	printTree(pseudo_head);
}

void Mol2D::printTree(loop *head, int spaces) {
	bp *b;
	res *r;
	static int hairpin_index = 0;
	static int n1 = 0;
	static int n2 = 0;
	
	if (head == NULL) {
		return;
	}

	cout << string(spaces, ' ') << "<Hairpin>" << endl;
	hairpin_index++;

	// print helix
	if (head->s.head != NULL) {
		n1++;
		cout << string(spaces + 2, ' ') << "<helix>" << endl;
		cout << string(spaces + 4, ' ') << "<ss>";
		int helix_len = head->s.getLen();
		for (int i = 0; i < helix_len; i++) {
			cout << '(';
		}
		for (int i = 0; i < helix_len; i++) {
			cout << ')';
		}
		cout << "</ss>" << endl;
		cout << string(spaces + 4, ' ') << "<nums>";
		for (b = head->s.head; b != NULL; b = b->next) {
			cout << b->res1.num << "-" << b->res2.num << ' ';
		}
		cout << "</nums>" << endl;
		cout << string(spaces + 2, ' ') << "</helix>" << endl;
	}

	// print loop
	if (head->head != NULL) {
		n2++;
		cout << string(spaces + 2, ' ') << "<loop>" << endl;
		cout << string(spaces + 4, ' ') << "<ss>";
		for (r = head->head; r != NULL; r = r->next) {
			cout << r->type;
		}
		cout << "</ss>" << endl;
		cout << string(spaces + 4, ' ') << "<nums>";
		for (r = head->head; r != NULL; r = r->next) {
			cout << r->num << ' ';
		}
		cout << "</nums>" << endl;
		cout << string(spaces + 4, ' ') << "<hinges>";
		for (auto &hinge : head->hinges) {
			cout << string(spaces, ' ') << '(' << hinge.first << ", " << hinge.second << ") ";
		}
		cout << "</hinges>" << endl;
		cout << string(spaces + 2, ' ') << "</loop>" << endl;
	}

	cout << string(spaces + 2, ' ') << "<son>" << endl;
	printTree(head->son, spaces + 4);
	cout << string(spaces + 2, ' ') << "</son>" << endl;
	cout << string(spaces + 2, ' ') << "<brother>" << endl;
	printTree(head->brother, spaces + 4);
	cout << string(spaces + 2, ' ') << "</brother>" << endl;

	cout << string(spaces, ' ') << "</Hairpin>" << endl;
}

void Mol2D::getLoop(vector<res> &v, vector<loop *> &s, int *a) {
	int flag1, flag2, flag3, min, i, j, k, num, num1, num2;
	res *tempRes, *preRes;
	bp *b, *preB;
	loop *l;
	static int n = 0;

	n++;

	for (flag3 = 0, j = v.size() - 1; v[j].type == ')'; j--, flag3++);
	for (flag2 = 0; v[j].type == '.' || v[j].type == '&' || v[j].type == '|' || v[j].type == '[' || v[j].type == ']'; j--, flag2++);
	for (flag1 = 0; v[j].type == '(' && flag1 < flag3; j--, flag1++);
	j++;

	// print start infomation
	if (view) {
		cout << "\n------------------ iteration " << n << "------------------\n";
		for (i = 0; i < (int) v.size(); i++) {
			if (v[i].type != '|') {
				cout << v[i].type;
			}
		}
		cout << endl;
	}
	
	// set loop
	l = new loop;
	k = j + flag1 - 2;
	tempRes = new res(v[k].type, v[k].num);
	preRes = tempRes;
	l->head = tempRes;
	for (k = j + flag1 - 1; k <= j + flag1 + flag2 + 1; k++) {
		tempRes = new res(v[k].type, v[k].num);
		preRes->next = tempRes;
		preRes = tempRes;
	}

	// set helix
	min = (flag1 > flag3) ? flag3 : flag1;
	k = 0;
	b = new bp;
	num1 = j + k;
	num2 = j + flag1 + flag2 + min - 1 - k;
	b->res1.type = v[num1].type;
	b->res2.type = v[num2].type;
	b->res1.num = v[num1].num;
	b->res2.num = v[num2].num;
	b->res1.next = b->res2.next = NULL;
	b->next = NULL;
	preB = b;
	l->s.head = b;
	l->s.len = min;
	for (k = 1; k < min; k++) {
		b = new bp;
		num1 = j + k;
		num2 = j + flag1 + flag2 + min - 1 - k;
		b->res1.type = v[num1].type;
		b->res2.type = v[num2].type;
		b->res1.num = v[num1].num;
		b->res2.num = v[num2].num;
		b->res1.next = b->res2.next = NULL;
		b->next = NULL;
		preB->next = b;
		preB = b;
	}

	// reset vector
	v.erase(v.begin() + j + flag1 - min, v.begin() + j + flag1 + flag2 + min);

	// add interface to loop
	int hinge_pos = 0;
	for (tempRes = l->head, l->type = 1; tempRes->next != NULL; tempRes = tempRes->next) {
		if (tempRes->next->num - tempRes->num > 1) {
			preRes = tempRes;
			tempRes = new res('(', preRes->num + 1);
			tempRes->next = preRes->next;
			preRes->next = tempRes;
			preRes = tempRes;
			hinge_pos++;
			tempRes = new res('(', preRes->num + 1);
			tempRes->next = preRes->next;
			preRes->next = tempRes;
			preRes = tempRes;
			hinge_pos++;
			l->hinges.push_back(pair<int, int>(hinge_pos, hinge_pos + 1));
			tempRes = new res(')', preRes->next->num - 2);
			tempRes->next = preRes->next;
			preRes->next = tempRes;
			preRes = tempRes;
			hinge_pos++;
			tempRes = new res(')', preRes->next->num - 1);
			tempRes->next = preRes->next;
			preRes->next = tempRes;
			hinge_pos++;
		}
		hinge_pos++;
	}

	// delete '|' from loop
	for (preRes = l->head, tempRes = preRes->next; tempRes != NULL; tempRes = tempRes->next) {
		if (tempRes->type == '|') {
			preRes->next = tempRes->next->next;
			delete tempRes->next;
			delete tempRes;
			tempRes = preRes->next;
		}
		preRes = tempRes;
	}

	// set tree relation
	num = l->getType();
	i = s.size() - num + 1;
	if (s.size() != 0 && num != 1) {
		l->son = s[i];
	}
	for (; i < (int) s.size(); i++) {
		if (i == (int) s.size() - 1) {
			s[i]->brother = NULL;
		} else {
			s[i]->brother = s[i + 1];
		}
	}
	for (k = 0; k < num - 1; k++) {
		s.pop_back();
	}

	// delete the loop which has only two residues
	if (l->getLen() == 4) {
		res *r1, *r2;
		r1 = l->head;
		r2 = l->head->next;
		for (; r2 != NULL; r2 = r2->next) {
			delete r1;
			r1 = r2;
		}
		delete r1;
		l->head = NULL;
	}

	// push new loop to s
	s.push_back(l);
	head = l;

	// view helix
	if (view) {
		cout << "helix: \n";
		for (b = l->s.head; b != NULL; b = b->next) {
			cout << a[b->res1.num] << '-' << a[b->res2.num] << endl;
		}

		if (v.size() != 0) {
			for (i = 0; i < (int) v.size(); i++) {
				if (v[i].type != '|') {
					cout << v[i].type;
				}
			}
			cout << endl;
		}
	}

	// view loop
	if (view && l->head != NULL) {
		cout << "loop(type:" << l->getType() << ") : \n";
		for (tempRes = l->head; tempRes != NULL; tempRes = tempRes->next) {
			cout << tempRes->type;
		}
		cout << endl;
		for (tempRes = l->head; tempRes != NULL; tempRes = tempRes->next) {
			cout << a[tempRes->num] << ' ';
		}
		cout << endl;
	}

	if (min == flag3) {
		return;
	} else {
		getLoop(v, s, a);
	}
}

void Mol2D::setPairs() {
	vector<int> v1;
	vector<int> v2;
	for (int i = 0; i < line.size(); i++) {
		if (line[i] == '(') {
			v1.push_back(i);
		} else if (line[i] == '[') {
			v2.push_back(i);
		} else if (line[i] == ')') {
			pairs[i] = v1.back();
			pairs[v1.back()] = i;
			v1.pop_back();
		} else if (line[i] == ']') {
std::cout << i << ' ' << v2.size() << ' ' << std::endl;
			pairs[i] = v2.back();
			pairs[v2.back()] = i;
			v2.pop_back();
		}
	}
}

void Mol2D::setLoops(loop *l) {
	if (l == NULL) {
		return;
	}
	if (l->head != NULL) {
		for (res *r = l->head; r != NULL; r = r->next) {
			if (r->num > 0 && r->num <= line.size()) {
				loops[r->num - 1] = l;
			}
		}
	}
	if (l->s.head != NULL) {
		for (bp *b = l->s.head; b != NULL; b = b->next) {
			if (b->res1.num >= 1 && b->res1.num <= line.size()) {
				loops[b->res1.num - 1] = l;
			}
			if (b->res2.num >= 1 && b->res2.num <= line.size()) {
				loops[b->res2.num - 1] = l;
			}
		}
	}
	setLoops(l->son);
	setLoops(l->brother);
}

list<loop *> Mol2D::find_path(loop *src, loop *target) {
	if (src == NULL) {
		return list<loop *>();
	} else if (src == target) {
		list<loop *> loop_list;
		loop_list.push_front(src);
		return loop_list;
	} else {
		list<loop *> son_loop_list = find_path(src->son, target);
		if (son_loop_list.begin() != son_loop_list.end()) {
			son_loop_list.push_front(src);
			return son_loop_list;
		} else {
			list<loop *> brother_loop_list = find_path(src->brother, target);
			if (brother_loop_list.begin() != brother_loop_list.end()) {
				return brother_loop_list;
			} else {
				return list<loop *>();
			}
		}
	}
}

void Mol2D::constructPseudoknots() {
	if (view) cout << "\n=============== construct pseudoknots ===================\n\n";

	// initialize loops
	pairs.resize(line.size(), -1);
	loops.resize(line.size(), NULL);
	
	setPairs();
	pseudo_head = loop::copy(head);
	setLoops(pseudo_head);
	int flag = 1;
	while (flag != 0) {
		flag = 0;
		
		// find path to root node
		for (int i = 0; i < line.size(); i++) {
			if (line[i] == '[') {
				if (loops[i] != loops[pairs[i]]) {
					flag++;
					list<loop *> list1 = find_path(pseudo_head, loops[i]);
					list<loop *> list2 = find_path(pseudo_head, loops[pairs[i]]);
					list<loop *>::iterator it1 = list1.begin();
					list<loop *>::iterator it2 = list2.begin();
					set<loop *> loop_set;
					loop *root;
					while (it1 != list1.end() || it2 != list2.end()) {
						if (it1 != list1.end() && it2 != list2.end()) {
							auto it11 = ++it1;
							it1--;
							auto it22 = ++it2;
							it2--;
							if (*it1 == *it2 && *it11 != *it22) {
								root = *it1;
								loop_set.insert(root);
							} else if (*it1 != *it2) {
								loop_set.insert(*it1);
								loop_set.insert(*it2);
							}
							it1++;
							it2++;
						} else if (it1 != list1.end() && it2 == list2.end()) {
							loop_set.insert(*it1);
							it1++;
						} else if (it1 == list1.end() && it2 != list2.end()) {
							loop_set.insert(*it2);
							it2++;
						}
					}

					// create pseudoknot
					//loop *l = new loop;
					loop *l = pseudo_loop(root, loop_set).front();
					l->type = -2;
					l->len = l->getLen();

					/*
					// set pseudoknot
					for (int i = ss.size() - 1; i >= 0; i--) {
						if (loops[i] == l) {
							res *r = new res(ss[i], i + 1);
							r->next = l->head;
							l->head = r;
							l->len++;
						}
					}
					*/

					// construct pseudoknot tree
					pseudo_tree(root, pseudo_head, loop_set, l);

					// set loops
					/*
					for (set<loop *>::iterator it = loop_set.begin(); it != loop_set.end(); it++) {
						for (bp *b = (*it)->s.head; b != NULL; b = b->next) {
							loops[b->res1.num - 1] = root;
							loops[b->res2.num - 1] = root;
						}
						for (res *r = (*it)->head; r != NULL; r = r->next) {
							loops[r->num - 1] = root;
						}
					}
					*/
					setLoops(pseudo_head);

					delete l;
				}
			}
		}
	}
}

list<loop *> Mol2D::pseudo_loop(loop *src, set<loop *> loop_set) {
	list<loop *> loop_list;

	if (src == NULL) {
		return loop_list;
	} else if (!loop_set.count(src)) {
		loop_list = pseudo_loop(src->brother, loop_set);
//		if (loop_list.begin() == loop_list.end()) {
//			return loop_list;
//		} else {
//			loop *l = new loop;
//			loop_list.push_front(l);
//			return loop_list;
//		}
		loop *l = new loop;
		loop_list.push_front(l);
		return loop_list;
	}

	loop *l = new loop(src);

	list<loop *> son_list = pseudo_loop(src->son, loop_set);
	if (son_list.begin() != son_list.end()) {
		int hinge_num = 0;
		for (res *temp_res = l->head; temp_res->next != NULL; temp_res = temp_res->next) {
		//for (res *temp_res = l->head; temp_res != NULL; temp_res = temp_res->next) {
			if (temp_res->type == '(' && temp_res->next->type == ')') {
				loop *l2 = son_list.front();

				if (l2->s.head == NULL && l2->head == NULL) {
					delete l2;
					son_list.pop_front();
					hinge_num++;
					continue;
				}

				// load helix
				if (l2->s.head != NULL) {
					for (bp *b = l2->s.head->next->next; b != NULL; b = b->next) {
						res *temp_next = temp_res->next;
						temp_res->next = new res(b->res1);
						temp_res = temp_res->next;
						temp_res->next = new res(b->res2);
						temp_res->next->next = temp_next;
					}
				}
				// load loop
				if (l2->head != NULL) {
					res *temp_next = temp_res->next;
					for (res *temp_res2 = l2->head->next->next; temp_res2->next->next != NULL; temp_res2 = temp_res2->next) {
						temp_res->next = new res(temp_res2);
						temp_res = temp_res->next;
					}
					temp_res->next = temp_next;
				}

				// update hinge position
				int helix_len_l2 = l2->s.getLen();
				int loop_len_l2 = l2->getLen();
				auto temp_pair = l->hinges[hinge_num];
				l->hinges.erase(l->hinges.begin() + hinge_num);
				int insert_pos = hinge_num;
				for (auto &hinge : l2->hinges) {
					l->hinges.insert(l->hinges.begin() + insert_pos, pair<int, int>(
						hinge.first + temp_pair.first + helix_len_l2, 
						hinge.second + temp_pair.first + helix_len_l2));
					insert_pos++;
					hinge_num++;
				}
				for (auto it = l->hinges.begin() + insert_pos; it != l->hinges.end(); it++) {
					if (helix_len_l2 != 0) {
						it->first += helix_len_l2 * 2 - 4;
						it->second += helix_len_l2 * 2 - 4;
					}
					if (loop_len_l2 != 0) {
						it->first += loop_len_l2 - 4;
						it->second += loop_len_l2 - 4;
					}
				}

				delete l2;
				son_list.pop_front();
			}
		}
	}

	list<loop *> brother_list = pseudo_loop(src->brother, loop_set);
	if (brother_list.begin() != brother_list.end()) {
		brother_list.push_front(l);
		return brother_list;
	} else {
		loop_list.push_front(l);
		return loop_list;
	}
}

int Mol2D::pseudo_tree(loop *root, loop *src, set<loop *> loop_set, loop *pseudo) {
	if (src == NULL) {
		return 0;
	} else {
		loop *son= src->son;
		loop *brother = src->brother;
		//pseudo_tree(root, son, loop_set, pseudo);
		//pseudo_tree(root, brother, loop_set, pseudo);
		if (pseudo_tree(root, son, loop_set, pseudo)) {
			src->son = NULL;
			son = NULL;
		}
		if (pseudo_tree(root, brother, loop_set, pseudo)) {
			src->brother = NULL;
			brother = NULL;
		}
		if (loop_set.count(src)) {
			if (src != root) {
				if (son != NULL) {
					loop *l;
					for (l = son; l->brother != NULL; l = l->brother);
					l->brother = brother;
					*src= *son;
					delete son;
				} else if (brother != NULL) {
					*src= *brother;
					delete brother;
				} else {
					delete src;
					return 1;
				}
			} else {
				pseudo->son = son;
				pseudo->brother = brother;
				*src= *pseudo;
			}
		}
	}
	return 0;
}


