#ifndef BUILD_NUC_H
#define BUILD_NUC_H

#include "../Pdb.h"

namespace jian {

namespace nuc3d {

class BuildNuc {
public:
	BuildNuc(string type = "RNA"): _type(type) {
		/// Set _lib
		char *lib = getenv("NSP");
		lib != NULL || die("Please designate environment variable 'NSP'");
		_lib = string() + lib + "/" + _type;

		/// Set _base_aa_par and _base_cg_par
		map<string, int> temp_map;
		map<string, vector<int>> temp_map2;
		if (_type == "RNA") {
			temp_map = {{"A", 11}, {"U", 9}, {"G", 12}, {"C", 9}};
			temp_map2 = {{"A", {0, 6, 8}}, {"U", {0, 3, 6}}, {"G", {0, 6, 9}}, {"C", {0, 3, 6}}};
		} else if (_type == "DNA") {
			temp_map = {{"DA", 11}, {"DT", 10}, {"DG", 12}, {"DC", 9}};
			temp_map2 = {{"DA", {0, 6, 8}}, {"DT", {0, 3, 6}}, {"DG", {0, 6, 9}}, {"DC", {0, 3, 6}}};
		}
		ifstream ifile;
		string par_file;
		for (auto &temp_pair: temp_map) {
			_base_aa_par[temp_pair.first].resize(temp_pair.second, 3);
			par_file = _lib + "/base/" + temp_pair.first;
			ifile.open(par_file.c_str());
			for (int i = 0; i < temp_pair.second; i++) {
				for (int j = 0; j < 3; j++) {
					ifile >> _base_aa_par[temp_pair.first](i, j);
				}
			}
			ifile.close();

			/// Set _base_cg_par
			_base_cg_par[temp_pair.first].resize(3, 3);
			for (int i = 0; i < 3; i++) {
				for (int j = 0; j < 3; j++) {
					_base_cg_par[temp_pair.first](i, j) =
						_base_aa_par[temp_pair.first](temp_map2[temp_pair.first][i], j);
				}
			}
		}

		/// Set _phos_sugar_par
		int temp_int;
		vector<string> name_list;
		if (_type == "RNA") {
			name_list = {"A", "U", "G", "C"};
			temp_int = 12;
		} else if (_type == "DNA") {
			name_list = {"DA", "DT", "DG", "DC"};
			temp_int = 11;
		}
		for (auto &name: name_list) {
			_phos_sugar_par[name].resize(temp_int, temp_int);
			par_file = _lib + "/pars/" + name + ".avg";
			ifile.open(par_file.c_str());
			for (int i = 0; i < temp_int; i++) {
				for (int j = 0; j < temp_int; j++) {
					ifile >> _phos_sugar_par[name](i, j);
				}
			}
			ifile.close();

			par_file = _lib + "/pars/" + name + ".stdev";
			ifile.open(par_file.c_str());
			for (int i = 0; i < temp_int; i++) {
				for (int j = 0; j < temp_int; j++) {
					double temp_double;
					ifile >> temp_double;
					_phos_sugar_par[name](i, j) += (i > j ? -3 : 3) * temp_double;
				}
			}
			ifile.close();
		}

		/// Set _atom_names
		if (_type == "RNA") {
			_atom_names = {
				{"A", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "O2*", "C1*", "N9", "C8", "N7", "C5", "C6", "N6", "N1", "C2", "N3", "C4"}},
				{"U", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "O2*", "C1*", "N1", "C2", "O2", "N3", "C4", "O4", "C5", "C6"}},
				{"G", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "O2*", "C1*", "N9", "C8", "N7", "C5", "C6", "O6", "N1", "C2", "N2", "N3", "C4"}},
				{"C", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "O2*", "C1*", "N1", "C2", "O2", "N3", "C4", "N4", "C5", "C6"}}
			};
		} else if (_type == "DNA") {
			_atom_names = {
				{"DA", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "C1*", "N9", "C8", "N7", "C5", "C6", "N6", "N1", "C2", "N3", "C4"}},
				{"DT", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "C1*", "N1", "C2", "O2", "N3", "C4", "O4", "C5", "C7", "C6"}},
				{"DG", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "C1*", "N9", "C8", "N7", "C5", "C6", "O6", "N1", "C2", "N2", "N3", "C4"}},
				{"DC", {"P", "O1P", "O2P", "O5*", "C5*", "C4*", "O4*", "C3*", "O3*", "C2*", "C1*", "N1", "C2", "O2", "N3", "C4", "N4", "C5", "C6"}}
			};
		}
	}

	Residue operator() (const string &name, const MatrixXf &scaffold);
	Residue make_residue(const string &name, const MatrixXf &coords);

private:
	string _type = "RNA";
	string _lib;
	map<string, MatrixXf> _base_aa_par;
	map<string, MatrixXf> _base_cg_par;
	map<string, MatrixXf> _phos_sugar_par;
	map<string, vector<string>> _atom_names;
};

} /// namespace nuc3d

} /// namespace jian





#endif

